# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KC-WMaTnxlU2l8xfoWyi9a99CHoN4g-_
"""

# !pip install dgl dglgo -f https://data.dgl.ai/wheels/repo.html &> /dev/null

import dgl
import dgl.function as fn
import torch
import torch.nn as nn
import torch.nn.functional as F
from dgl import DGLGraph
import random
from dgl.data import CoraGraphDataset
from dgl.nn import GraphConv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt




def train(g, total_epochs):

    features = g.ndata['feat']
    labels = g.ndata['label']
    train_mask = g.ndata['train_mask']
    test_mask = g.ndata['test_mask']
  
    number_of_features = g.ndata['feat'].shape[1]


    class Net(nn.Module):
        def __init__(self):
            super(Net, self).__init__()
            self.layer1 = GraphConv(number_of_features, 8*16) # Não preciso mudar o 1433, é o numero fixo de features
            self.layer2 = GraphConv(8*16, 7)    


        def forward(self, g, features):
            x1 = F.relu(self.layer1(g, features)) #ReLU activation function
            x2 = self.layer2(g, x1)
            return x2
    net = Net()

    def evaluate(model, graph, features, labels, mask):
        model.eval()
        with torch.no_grad():
            logits = model(graph, features)
            logits = logits[mask]
            labels = labels[mask]
            _, indices = torch.max(logits, dim=1)
            correct = torch.sum(indices == labels)
            return correct.item() * 1.0 / len(labels)


    g.add_edges(g.nodes(), g.nodes())
    optimizer = torch.optim.Adam(net.parameters(), lr=1e-2)
    loss_list=[]
    acc_list=[]
    all_logits=[]
    for epoch in range(total_epochs):
        net.train()
        logits = net(g, features)

        #print(logits)
        logp = F.log_softmax(logits, 1)
        all_logits.append(logp)
        loss = F.nll_loss(logp[train_mask], labels[train_mask])

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        acc = evaluate(net, g, features, labels, test_mask)
        loss_list.append(loss.item())
        acc_list.append(acc)


    df=pd.DataFrame(all_logits[-1][:].detach().numpy())
    lista=[]
    for i in range(len(labels)):
        lista.append((all_logits[-1][i].detach().numpy().argmax()))

    df['Class']=pd.Series(lista)

    df.head()

 

    plt.rcParams["figure.figsize"] = [18, 10]
    plt.rcParams["figure.autolayout"] = True

    x = range(0, len(acc_list))
    y = acc_list


    precisao_final = acc_list[-1]
 
    return precisao_final